---
description:
globs:
alwaysApply: false
---
---
description: Inngest workflow automation best practices including function definitions, event patterns, and client configuration
globs: []
alwaysApply: false
---

<inngest-guidelines>

<title>Inngest Workflow Automation Best Practices</title>

<core-setup>

### Installation & Configuration
```typescript
// lib/inngest.ts
import { Inngest } from "inngest"

export const inngest = new Inngest({ 
  id: "my-app",
  name: "My App",
  isDev: process.env.NODE_ENV === "development",
})

// Environment-specific configuration
export const inngestConfig = {
  signingKey: process.env.INNGEST_SIGNING_KEY!,
  eventKey: process.env.INNGEST_EVENT_KEY!,
  servePath: "/api/inngest"
}
```

### API Route Handler
```typescript
// app/api/inngest/route.ts
import { serve } from "inngest/next"
import { inngest } from "@/lib/inngest"
import { helloWorld } from "@/inngest/hello-world"
import { processPayment } from "@/inngest/process-payment"
import { sendEmailSequence } from "@/inngest/send-email-sequence"
import { cleanupExpiredSessions } from "@/inngest/cleanup-sessions"

// Export all your functions in an array
export const { GET, POST, PUT } = serve({
  client: inngest,
  functions: [
    helloWorld,
    processPayment,
    sendEmailSequence,
    cleanupExpiredSessions,
  ]
})
```

## Basic Functions

### Simple Event Handler
```typescript
// inngest/hello-world.ts
import { inngest } from "@/lib/inngest"

export const helloWorld = inngest.createFunction(
  { id: "hello-world" },
  { event: "demo/hello.world" },
  async ({ event, step }) => {
    await step.run("log-hello", async () => {
      console.log(`Hello, ${event.data.name}!`)
      return { message: `Hello, ${event.data.name}!` }
    })
    
    return { 
      message: "Function completed successfully",
      data: event.data 
    }
  }
)

// Usage: Send event from anywhere in your app
// await inngest.send({ name: "demo/hello.world", data: { name: "World" } })
```

### Multi-Step Workflow
```typescript
// inngest/process-payment.ts
import { inngest } from "@/lib/inngest"

export const processPayment = inngest.createFunction(
  { 
    id: "process-payment",
    retries: 3,
    concurrency: {
      limit: 10,
      key: "event.data.userId"
    }
  },
  { event: "payment/process" },
  async ({ event, step }) => {
    const { userId, amount, paymentMethodId } = event.data

    // Step 1: Validate payment method
    const paymentMethod = await step.run("validate-payment-method", async () => {
      const stripe = await import("stripe")
      const stripeClient = new stripe.default(process.env.STRIPE_SECRET_KEY!)
      
      return await stripeClient.paymentMethods.retrieve(paymentMethodId)
    })

    // Step 2: Create payment intent
    const paymentIntent = await step.run("create-payment-intent", async () => {
      const stripe = await import("stripe")
      const stripeClient = new stripe.default(process.env.STRIPE_SECRET_KEY!)
      
      return await stripeClient.paymentIntents.create({
        amount: amount * 100, // Convert to cents
        currency: "usd",
        payment_method: paymentMethodId,
        customer: userId,
        confirm: true,
        return_url: `${process.env.NEXT_PUBLIC_BASE_URL}/payment/success`,
      })
    })

    // Step 3: Update database
    const dbUpdate = await step.run("update-database", async () => {
      const { prisma } = await import("@/lib/prisma")
      
      return await prisma.payment.create({
        data: {
          userId,
          stripePaymentIntentId: paymentIntent.id,
          amount,
          status: paymentIntent.status,
        }
      })
    })

    // Step 4: Send confirmation email
    await step.run("send-confirmation-email", async () => {
      const { resend } = await import("@/lib/resend")
      
      await resend.emails.send({
        from: "noreply@yourapp.com",
        to: event.data.userEmail,
        subject: "Payment Confirmation",
        html: `
          <h1>Payment Successful</h1>
          <p>Your payment of $${amount} has been processed successfully.</p>
          <p>Payment ID: ${paymentIntent.id}</p>
        `
      })
    })

    // Step 5: Trigger follow-up events
    await step.sendEvent("send-welcome-sequence", {
      name: "user/welcome.sequence",
      data: { userId, paymentId: dbUpdate.id }
    })

    return {
      success: true,
      paymentIntentId: paymentIntent.id,
      databaseId: dbUpdate.id
    }
  }
)
```

## Scheduled Functions (Cron Jobs)

### Periodic Cleanup
```typescript
// inngest/cleanup-sessions.ts
import { inngest } from "@/lib/inngest"

export const cleanupExpiredSessions = inngest.createFunction(
  { id: "cleanup-expired-sessions" },
  { cron: "0 2 * * *" }, // Run daily at 2 AM
  async ({ step }) => {
    const deletedSessions = await step.run("delete-expired-sessions", async () => {
      const { prisma } = await import("@/lib/prisma")
      
      const result = await prisma.session.deleteMany({
        where: {
          expiresAt: {
            lt: new Date()
          }
        }
      })
      
      return result.count
    })

    const deletedTokens = await step.run("delete-expired-tokens", async () => {
      const { prisma } = await import("@/lib/prisma")
      
      const result = await prisma.verificationToken.deleteMany({
        where: {
          expiresAt: {
            lt: new Date()
          }
        }
      })
      
      return result.count
    })

    // Log cleanup results
    await step.run("log-cleanup-results", async () => {
      console.log(`Cleanup completed: ${deletedSessions} sessions, ${deletedTokens} tokens deleted`)
    })

    return {
      sessionsDeleted: deletedSessions,
      tokensDeleted: deletedTokens,
      cleanupDate: new Date().toISOString()
    }
  }
)
```

### Report Generation
```typescript
// inngest/generate-reports.ts
import { inngest } from "@/lib/inngest"

export const generateWeeklyReport = inngest.createFunction(
  { id: "generate-weekly-report" },
  { cron: "0 9 * * 1" }, // Every Monday at 9 AM
  async ({ step }) => {
    const reportData = await step.run("collect-report-data", async () => {
      const { prisma } = await import("@/lib/prisma")
      
      const endDate = new Date()
      const startDate = new Date(endDate.getTime() - 7 * 24 * 60 * 60 * 1000)

      const [users, payments, orders] = await Promise.all([
        prisma.user.count({
          where: { createdAt: { gte: startDate, lt: endDate } }
        }),
        prisma.payment.aggregate({
          where: { createdAt: { gte: startDate, lt: endDate } },
          _sum: { amount: true },
          _count: true
        }),
        prisma.order.count({
          where: { createdAt: { gte: startDate, lt: endDate } }
        })
      ])

      return {
        period: { start: startDate, end: endDate },
        newUsers: users,
        totalRevenue: payments._sum.amount || 0,
        totalPayments: payments._count,
        totalOrders: orders
      }
    })

    const reportHtml = await step.run("generate-report-html", async () => {
      return `
        <h1>Weekly Report</h1>
        <h2>Period: ${reportData.period.start.toDateString()} - ${reportData.period.end.toDateString()}</h2>
        <ul>
          <li>New Users: ${reportData.newUsers}</li>
          <li>Total Revenue: $${reportData.totalRevenue}</li>
          <li>Total Payments: ${reportData.totalPayments}</li>
          <li>Total Orders: ${reportData.totalOrders}</li>
        </ul>
      `
    })

    await step.run("email-report", async () => {
      const { resend } = await import("@/lib/resend")
      
      await resend.emails.send({
        from: "reports@yourapp.com",
        to: "admin@yourapp.com",
        subject: `Weekly Report - ${reportData.period.end.toDateString()}`,
        html: reportHtml
      })
    })

    return reportData
  }
)
```

## Email Sequences & Drip Campaigns

### Welcome Email Sequence
```typescript
// inngest/send-email-sequence.ts
import { inngest } from "@/lib/inngest"

export const sendWelcomeSequence = inngest.createFunction(
  { id: "send-welcome-sequence" },
  { event: "user/welcome.sequence" },
  async ({ event, step }) => {
    const { userId } = event.data

    // Get user details
    const user = await step.run("get-user", async () => {
      const { prisma } = await import("@/lib/prisma")
      return await prisma.user.findUnique({
        where: { id: userId },
        select: { email: true, name: true, createdAt: true }
      })
    })

    if (!user) {
      throw new Error("User not found")
    }

    // Welcome email (immediate)
    await step.run("send-welcome-email", async () => {
      const { resend } = await import("@/lib/resend")
      
      await resend.emails.send({
        from: "welcome@yourapp.com",
        to: user.email,
        subject: "Welcome to Our Platform!",
        html: `
          <h1>Welcome, ${user.name}!</h1>
          <p>We're excited to have you on board.</p>
          <p>Here are some next steps to get you started:</p>
          <ul>
            <li>Complete your profile</li>
            <li>Explore our features</li>
            <li>Join our community</li>
          </ul>
        `
      })
    })

    // Follow-up email (after 3 days)
    await step.sleepUntil("wait-3-days", 
      new Date(Date.now() + 3 * 24 * 60 * 60 * 1000)
    )

    await step.run("send-tips-email", async () => {
      const { resend } = await import("@/lib/resend")
      
      await resend.emails.send({
        from: "tips@yourapp.com",
        to: user.email,
        subject: "Pro Tips for Getting Started",
        html: `
          <h1>Here are some pro tips, ${user.name}!</h1>
          <p>To help you get the most out of our platform:</p>
          <ul>
            <li>Tip 1: Customize your dashboard</li>
            <li>Tip 2: Set up notifications</li>
            <li>Tip 3: Connect with other users</li>
          </ul>
        `
      })
    })

    // Final email (after 7 days)
    await step.sleepUntil("wait-7-days", 
      new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
    )

    await step.run("send-feedback-email", async () => {
      const { resend } = await import("@/lib/resend")
      
      await resend.emails.send({
        from: "feedback@yourapp.com",
        to: user.email,
        subject: "How's your experience so far?",
        html: `
          <h1>We'd love your feedback, ${user.name}!</h1>
          <p>You've been with us for a week now. How are things going?</p>
          <p>We'd love to hear about your experience and how we can improve.</p>
          <a href="${process.env.NEXT_PUBLIC_BASE_URL}/feedback">Share Your Feedback</a>
        `
      })
    })

    return { success: true, emailsSent: 3 }
  }
)
```

## Error Handling & Retries

### Robust Function with Error Handling
```typescript
// inngest/process-webhook.ts
import { inngest } from "@/lib/inngest"
import { NonRetriableError } from "inngest"

export const processWebhook = inngest.createFunction(
  { 
    id: "process-webhook",
    retries: 5,
    rateLimit: {
      limit: 100,
      period: "1m"
    }
  },
  { event: "webhook/received" },
  async ({ event, step, attempt }) => {
    const { source, data, headers } = event.data

    // Step 1: Validate webhook signature
    const isValid = await step.run("validate-signature", async () => {
      try {
        // Example for Stripe webhook validation
        if (source === "stripe") {
          const stripe = await import("stripe")
          const stripeClient = new stripe.default(process.env.STRIPE_SECRET_KEY!)
          
          const signature = headers['stripe-signature']
          const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET!
          
          stripeClient.webhooks.constructEvent(
            JSON.stringify(data),
            signature,
            endpointSecret
          )
          
          return true
        }
        
        return true
      } catch (error) {
        // Invalid signature - don't retry
        throw new NonRetriableError("Invalid webhook signature")
      }
    })

    // Step 2: Process webhook data
    const result = await step.run("process-data", async () => {
      try {
        switch (data.type) {
          case "payment_intent.succeeded":
            return await handlePaymentSuccess(data.data.object)
          
          case "customer.subscription.created":
            return await handleSubscriptionCreated(data.data.object)
          
          case "invoice.payment_failed":
            return await handlePaymentFailed(data.data.object)
          
          default:
            console.log(`Unhandled webhook type: ${data.type}`)
            return { processed: false, reason: "Unhandled type" }
        }
      } catch (error) {
        // Log error with context
        console.error("Webhook processing failed:", {
          attempt,
          source,
          type: data.type,
          error: error.message
        })
        
        // Retry for transient errors
        if (error.message.includes("timeout") || error.message.includes("network")) {
          throw error // Will be retried
        }
        
        // Don't retry for permanent errors
        throw new NonRetriableError(`Processing failed: ${error.message}`)
      }
    })

    // Step 3: Send notifications if needed
    if (result.shouldNotify) {
      await step.run("send-notification", async () => {
        // Send notification logic here
        return await sendSlackNotification({
          channel: "#webhooks",
          message: `Webhook processed: ${source} - ${data.type}`,
          data: result
        })
      })
    }

    return result
  }
)

async function handlePaymentSuccess(paymentIntent: any) {
  // Handle successful payment
  return { processed: true, shouldNotify: true }
}

async function handleSubscriptionCreated(subscription: any) {
  // Handle new subscription
  return { processed: true, shouldNotify: true }
}

async function handlePaymentFailed(invoice: any) {
  // Handle failed payment
  return { processed: true, shouldNotify: true }
}

async function sendSlackNotification(params: any) {
  // Slack notification implementation
  return { sent: true }
}
```

## Testing Functions

### Function Testing
```typescript
// tests/inngest/hello-world.test.ts
import { describe, it, expect, vi } from "vitest"
import { helloWorld } from "@/inngest/hello-world"

describe("helloWorld function", () => {
  it("should process hello world event", async () => {
    const mockStep = {
      run: vi.fn().mockImplementation(async (name, fn) => await fn())
    }

    const result = await helloWorld.handler({
      event: {
        name: "demo/hello.world",
        data: { name: "Test User" }
      },
      step: mockStep,
      attempt: 1
    })

    expect(result.message).toBe("Function completed successfully")
    expect(result.data.name).toBe("Test User")
    expect(mockStep.run).toHaveBeenCalledWith("log-hello", expect.any(Function))
  })
})
```

## Sending Events

### From API Routes
```typescript
// app/api/users/route.ts
import { NextRequest, NextResponse } from "next/server"
import { inngest } from "@/lib/inngest"

export async function POST(request: NextRequest) {
  const userData = await request.json()
  
  // Create user in database
  const user = await createUser(userData)
  
  // Trigger welcome sequence
  await inngest.send({
    name: "user/welcome.sequence",
    data: {
      userId: user.id,
      userEmail: user.email,
      userName: user.name
    }
  })
  
  return NextResponse.json(user)
}
```

### From Client Components
```typescript
// components/payment-form.tsx
"use client"

import { useState } from "react"

export function PaymentForm() {
  const [isProcessing, setIsProcessing] = useState(false)

  const handlePayment = async (paymentData: any) => {
    setIsProcessing(true)
    
    try {
      // Send payment event to Inngest
      const response = await fetch("/api/process-payment", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(paymentData)
      })
      
      if (response.ok) {
        // Payment processing started
        console.log("Payment processing initiated")
      }
    } finally {
      setIsProcessing(false)
    }
  }

  return (
    <button 
      onClick={() => handlePayment({ amount: 99.99, userId: "user123" })}
      disabled={isProcessing}
    >
      {isProcessing ? "Processing..." : "Pay Now"}
    </button>
  )
}
```

## Best Practices

1. **Idempotency**: Make functions idempotent by using unique keys for operations
2. **Error Handling**: Use NonRetriableError for permanent failures
3. **Step Organization**: Break complex workflows into logical steps
4. **Concurrency Control**: Use concurrency limits to prevent overwhelming external services
5. **Rate Limiting**: Implement rate limits for API-heavy functions
6. **Monitoring**: Add logging and monitoring for production functions
7. **Testing**: Write unit tests for function logic
8. **Event Naming**: Use consistent, descriptive event names
9. **Data Validation**: Validate event data before processing
10. **Retries**: Configure appropriate retry strategies for different error types

<inngest-best-practices>

<title>Inngest Workflow Automation Best Practices</title>

<function-definition>
<rules>
- Use TypeScript for type-safe function definitions
- Define clear event schemas with proper validation
- Use descriptive function names and IDs
- Implement proper error handling and retries
- Use step functions for complex workflows
- Configure appropriate timeouts and concurrency
</rules>

<examples>
<example type="good">
```typescript
// inngest/functions/user-onboarding.ts
import { inngest } from "@/inngest/client";
import { z } from "zod";

// Event schema validation
const UserSignedUpSchema = z.object({
  userId: z.string(),
  email: z.string().email(),
  name: z.string(),
  plan: z.enum(['free', 'pro', 'enterprise']),
});

export const userOnboarding = inngest.createFunction(
  {
    id: "user-onboarding",
    name: "User Onboarding Flow",
    concurrency: {
      limit: 10,
    },
    retries: {
      attempts: 3,
    },
  },
  { event: "user/signed-up" },
  async ({ event, step }) => {
    // Validate event data
    const userData = UserSignedUpSchema.parse(event.data);
    
    // Step 1: Send welcome email
    const emailResult = await step.run("send-welcome-email", async () => {
      return await sendWelcomeEmail(userData.email, userData.name);
    });
    
    // Step 2: Create user profile with retry
    const profile = await step.run("create-user-profile", async () => {
      return await createUserProfile(userData);
    });
    
    // Step 3: Setup based on plan (conditional)
    if (userData.plan !== 'free') {
      await step.run("setup-premium-features", async () => {
        return await setupPremiumFeatures(userData.userId, userData.plan);
      });
    }
    
    // Step 4: Schedule follow-up (delayed)
    await step.sleep("wait-for-follow-up", "3d");
    
    const followUpResult = await step.run("send-follow-up", async () => {
      return await sendFollowUpEmail(userData.email);
    });
    
    return {
      success: true,
      userId: userData.userId,
      emailSent: emailResult.success,
      profileCreated: !!profile,
      followUpSent: followUpResult.success,
    };
  }
);

// Background job with scheduling
export const dailyReports = inngest.createFunction(
  {
    id: "daily-reports",
    name: "Generate Daily Reports",
  },
  { cron: "0 9 * * *" }, // Daily at 9 AM
  async ({ step }) => {
    // Generate user activity report
    const userReport = await step.run("generate-user-report", async () => {
      return await generateUserActivityReport();
    });
    
    // Generate revenue report
    const revenueReport = await step.run("generate-revenue-report", async () => {
      return await generateRevenueReport();
    });
    
    // Send to stakeholders
    await step.run("send-reports", async () => {
      return await sendReportsToStakeholders([userReport, revenueReport]);
    });
    
    return { reportsGenerated: true };
  }
);
```
</example>
</examples>
</function-definition>

<event-patterns>
<rules>
- Use consistent event naming conventions
- Include proper event versioning
- Add relevant metadata to events
- Use event batching for high-volume scenarios
- Implement event replay capabilities
- Use proper event routing and filtering
</rules>

<examples>
<example type="good">
```typescript
// Event definitions and schemas
// lib/events.ts
import { z } from "zod";

export const EventSchemas = {
  "user/signed-up": z.object({
    userId: z.string(),
    email: z.string().email(),
    name: z.string(),
    plan: z.enum(['free', 'pro', 'enterprise']),
    source: z.string(),
    timestamp: z.string(),
  }),
  
  "order/created": z.object({
    orderId: z.string(),
    userId: z.string(),
    amount: z.number(),
    currency: z.string(),
    items: z.array(z.object({
      productId: z.string(),
      quantity: z.number(),
      price: z.number(),
    })),
  }),
  
  "payment/completed": z.object({
    paymentId: z.string(),
    orderId: z.string(),
    amount: z.number(),
    currency: z.string(),
    method: z.string(),
  }),
};

// Event emission helpers
export class EventEmitter {
  static async emitUserSignedUp(userData: {
    userId: string;
    email: string;
    name: string;
    plan: 'free' | 'pro' | 'enterprise';
    source: string;
  }) {
    await inngest.send({
      name: "user/signed-up",
      data: {
        ...userData,
        timestamp: new Date().toISOString(),
      },
    });
  }
  
  static async emitOrderCreated(orderData: {
    orderId: string;
    userId: string;
    amount: number;
    currency: string;
    items: Array<{
      productId: string;
      quantity: number;
      price: number;
    }>;
  }) {
    await inngest.send({
      name: "order/created",
      data: orderData,
    });
  }
  
  // Batch event emission
  static async emitBatch(events: Array<{
    name: string;
    data: any;
  }>) {
    await inngest.send(events);
  }
}
```
</example>
</examples>
</event-patterns>

<client-configuration>
<rules>
- Configure proper client settings for your environment
- Use environment variables for API keys and URLs
- Implement proper middleware for logging and monitoring
- Set up proper error handling and retry policies
- Configure webhooks for production deployment
- Use proper signing key validation
</rules>

<examples>
<example type="good">
```typescript
// inngest/client.ts
import { Inngest } from "inngest";
import { z } from "zod";

const envSchema = z.object({
  INNGEST_EVENT_KEY: z.string(),
  INNGEST_SIGNING_KEY: z.string(),
  INNGEST_ENV: z.string().optional(),
  NODE_ENV: z.enum(['development', 'staging', 'production']),
});

const env = envSchema.parse(process.env);

export const inngest = new Inngest({
  id: "my-app",
  name: "My Application",
  eventKey: env.INNGEST_EVENT_KEY,
  isDev: env.NODE_ENV === 'development',
  env: env.INNGEST_ENV,
  middleware: [
    // Logging middleware
    {
      name: "logger",
      init: ({ client }) => {
        return {
          onFunctionRun: ({ ctx, fn }) => {
            console.log(`Starting function: ${fn.name}`, {
              runId: ctx.runId,
              event: ctx.event,
            });
          },
          onStepRun: ({ ctx, step }) => {
            console.log(`Executing step: ${step.displayName}`, {
              runId: ctx.runId,
              stepId: step.id,
            });
          },
          transformOutput: ({ result }) => {
            console.log("Function completed", { result });
            return result;
          },
        };
      },
    },
    // Error tracking middleware
    {
      name: "error-tracker",
      init: () => {
        return {
          transformOutput: ({ result, step }) => {
            if (result.error) {
              console.error("Step failed", {
                stepId: step?.id,
                error: result.error,
              });
              // Send to error tracking service
            }
            return result;
          },
        };
      },
    },
  ],
});

// API route for webhooks
// pages/api/inngest.ts (Next.js) or equivalent
import { serve } from "inngest/next";
import { inngest } from "@/inngest/client";
import { userOnboarding, dailyReports, orderProcessing } from "@/inngest/functions";

export default serve({
  client: inngest,
  functions: [
    userOnboarding,
    dailyReports,
    orderProcessing,
    // Add all your functions here
  ],
  signingKey: process.env.INNGEST_SIGNING_KEY!,
  landingPage: false, // Disable in production
});
```
</example>
</examples>
</client-configuration>

<best-practices>
<function-design>
- Keep functions focused on single responsibilities
- Use descriptive names and proper documentation
- Implement comprehensive error handling
- Use step functions for complex workflows
- Design for idempotency and retries
- Monitor function performance and costs
</function-design>

<event-management>
- Use consistent naming conventions
- Include proper event versioning
- Validate event schemas thoroughly
- Implement event replay capabilities
- Use batching for high-volume events
- Monitor event processing metrics
</event-management>

<error-handling>
- Implement proper retry strategies
- Use step-level error handling
- Set appropriate timeouts
- Log errors with sufficient context
- Implement dead letter queues
- Monitor and alert on failures
</error-handling>

<performance>
- Use parallel steps for independent operations
- Implement proper caching strategies
- Monitor function execution times
- Optimize payload sizes
- Use appropriate concurrency limits
- Profile and optimize slow functions
</performance>
</best-practices>

</inngest-best-practices>
